#! /app/.heroku/node/bin/node

function sendEmail(CountLeft) {
    console.log("You are running low on Sensors!!! \n Notify owner to get more!");
    var nodemailer = require('nodemailer');
    var transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
            user: process.env.EMAIL_FROM,
            pass: process.env.EMAIL_FROM_PASS
        }
    });

    var today = new Date();
    let url = "https://" + process.env.HEROKU_APP_NAME + ".herokuapp.com";
    var htmlContent = 'Du har nu bara: ' + CountLeft + " kvar...<br/>";
    htmlContent += 'Klicka <a href="' + url + '/sensor">här</a> för att öppna kontroll-sidan<br/>';
    htmlContent += 'Eller använd snabblänkarna för att lägga till önskat antal sensorer:<br/>'
    htmlContent += '<a href="' + url + '/addtosensorcount/-1" style="margin-right:15px;">-1</a><a href="' + url + '/addtosensorcount/1" style="margin-right:15px;">+1</a>        ';
    htmlContent += '<a href="' + url + '/addtosensorcount/5" style="margin-right:15px;">+5</a><a href="' + url + '/addtosensorcount/10" style="margin-right:15px;">+10</a>';

    var mailOptions = {
        from: process.env.EMAIL_FROM,
        to: process.env.EMAIL_TO,
        subject: 'Dags att beställa fler sensorer! (' + today.getDate() + "/" + today.getMonth()+1 + ")",
        //text: 'Du har nu bara: ' + CountLeft + " kvar..."
        html: htmlContent
    };

    transporter.sendMail(mailOptions, function (error, info) {
        if (error) {
            console.log(error);
        } else {
            console.log('Email sent: ' + info.response);
        }
    });
}

async function checkSensorState() {
    // we create 'users' collection in newdb database
    var url = process.env.CONNSTR_mongo;

    // create a client to mongodb
    var MongoClient = require('mongodb').MongoClient;

    // make client connect to mongo service
    const dbClient = await MongoClient.connect(url);
    if (!dbClient) {
        console.log("failed to connect to mongodb!\nCheck your connection string: " + process.env.CONNSTR_mongo)
        return;
    }
    var db = null;
    try {
        db = dbClient.db('nightscout');
        // db pointing to newdb
        console.log("Switched to " + db.databaseName + " database");
        // create 'users' collection in newdb database
        await db.createCollection("omnipodstash");

    } catch (err) {
        if (err.message == 'Collection already exists. NS: nightscout.omnipodstash') {
            console.log("omnipodstash exists!")
        }
        else {
            dbClient.close();
            console.log(err);
            process.exit(); //for heroku
        }
    }
    var count = 0;
    var lastKnownChange = null;
    try {
        //fetch last entry in omnipodstash
        let doc = await db.collection("omnipodstash")
            .find({ Type: "sensor" }, { projection: { _id: 0 } })
            .sort({ $natural: -1 }) //bottomsup
            .limit(1)
            .next();

        if (doc != null && doc.hasOwnProperty('SensorCount')) {
            count = doc.SensorCount;
            lastKnownChange = doc.LastKnownSensorChange;
            console.log('count: ' + count);
            console.log('lastKnownSensorChange: ' + lastKnownChange);
        }

        if (lastKnownChange != null) {
            //fetch nr of new sensors-changes: 
            let docTreatments = await db.collection("treatments")
                .aggregate([
                    {
                        "$match": {
                            "created_at": {
                                "$gt": lastKnownChange
                            },
                            "eventType": "Sensor Change"
                        }
                    },
                    {
                        "$group": {
                            "_id": "$eventType",
                            "count": { "$sum": 1 }
                        }
                    }
                ])
                .next();

            var newUsedcount= 0;

            if (docTreatments != null) {
                newUsedcount= docTreatments.count;
            }
            console.log("newUsedSensors:" + newUsedcount);

            let sensorCount = count - newUsedcount;
            if (sensorCount < process.env.SENSORLIMIT) {
                //TODO notify user (email, telegram...? )
                sendEmail(sensorCount);
                //give it some time before exit...
                await new Promise(resolve => setTimeout(resolve, 5000));
            }
            if(newUsedcount == 0){
                dbClient.close();
                process.exit();//for heroku
            }
            //fetch date of last used: 
            let docLastUsedSensor = await db.collection("treatments")
                .find({eventType: "Sensor Change"}, { projection: { created_at: 1 } })
                .sort({ $natural: -1 })
                .limit(1)
                .next();

            let lastSensorChange = docLastUsedSensor.created_at;
            //create new db-object
            var dbEntity = {
                date: new Date().toISOString(),
                diff: -newUsedcount,
                PodCount: null,
                SensorCount: sensorCount,
                LastKnownPodChange: null,
                LastKnownSensorChange: lastSensorChange,
                operation: "Scheduled Task",
                Type: "sensor"
            };

            //update omnipodstash with latest: 
            await db.collection("omnipodstash").insertOne(dbEntity);

            console.log("1 document inserted:");
            console.log(dbEntity);

        } else {
            //first time = omnipodstash is empty.
            //update with latest sensor and zero stash:
            //fetch date of last used pod: 
            let doclastUsed = await db.collection("treatments")
                .find({eventType: "Sensor Change"}, { projection: { created_at: 1 } })
                .sort({ $natural: -1 })
                .limit(1)
                .next();

            let lastPodChange = doclastUsed.created_at;
            var dbEntity = {
                date: new Date().toISOString(),
                diff: 0,
                PodCount: 0,
                SensorCount: 0,
                LastKnownPodChange: null,
                LastKnownSensorChange: lastPodChange,
                operation: "Scheduled Task",
                Type: "sensor"
            };
            //update db: 
            await db.collection("omnipodstash").insertOne(dbEntity);
            console.log("1 document inserted:");
            console.log(dbEntity);
            sendEmail(0);
            //give it some time before exit...
            await new Promise(resolve => setTimeout(resolve, 5000));
            // close the connection to db when you are done with it
        }


    } catch (err) {
        console.log(err);
    } finally {
        // close the connection to db when you are done with it
        dbClient.close();
        process.exit();//for heroku
    }

}
checkSensorState();
